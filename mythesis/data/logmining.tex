% vim:textwidth=70
\chapter{基于日志的系统模型推断算法}
\label{chap:logmining}

随着云计算逐渐影响人们的生活，分布式系统变的越来越重要，成了Internet应
用的关键组成部分[1][2][3][4]。分布式系统运行在多台机器上，充分发掘并调
度机器资源，以提供高吞吐率、低延迟的服务，同时，还要处理各种不同类型的
系统失败事件（failure）。由于系统规模庞大，并且有严格的服务质量要求，
设计与实现这类分布式系统不可避免的会产生错误（bug），从而使系统表现出
未预期的行为。系统错误的根本原因通常隐含在复杂的应用逻辑之下，找到这些
错误通常会花费很长时间。

理解分布式系统的运行时行为是验证系统设计、发现系统逻辑与性能问题、解决
系统实现错误的关键。然而，即使对系统的实现者来说，充分理解系统逻辑也不
是一件轻而易举的事情。这是因为，系统设计非常复杂，它的运行时行为多种多
样。再者，系统通常由一组程序员共同开发，并且在不停的演变至新的版本。进
一步说，分布式系统通常会使用分层的设计模式，用户请求由不同层次的模块处
理。上层模块中的某个函数，会由下层模块的多个函数一起完成，其完成方式，
可能是顺序的，也可能是并行的，跨越多个机器、进程与线程。以上这些状况，
都增加了理解系统运行时行为的困难。

已有的方法表明，用分层的任务模型去表达系统行为，可以很好的帮助程序员理
解与验证系统。例如，Pip[5]允许程序员定义可嵌套的任务流，并定义“期望”，
来发现异常。用这个方法，程序员能够定义并验证系统特定层次的特性。这种方
法被证明能够很有效的发现系统错误与性能问题。我们之前的工作Scalpel[6]进
一步发展了一种方法，能够从底层系统调用trace中，自动推断任务模型，从而
避免了手动定义任务结构的工作。初步的结果表明，从操作系统级别的同步操作，
我们能够推断出合理的表达上层语意的层次化任务模型。利用得到的模型，我们
能够帮助程序员快速的发现并解决系统性能问题。

我们最终的目标是设计一个完全不需要或尽可能少需要人工标注的工具，来自动
提取系统的分层任务模型，帮助程序员、测试人员和系统管理员理解系统运行时
行为。基于之前的工作，在本文中，我们重点研究了如何利用应用日志（log）
来推断任务模型。其基本原理是，相比底层 trace，应用日志包含了更多的应用
层任务流的语意。日志是由系统开发人员创建的，因此它们包含了关键的系统状
态和事件信息，例如，用户层任务的开始和结束，处理用户请求的关键步骤等等。
利用这些信息，可以帮助我们推断用户层语意，而这些很难从系统调用trace中
得到。

使用日志推断分层任务模型需要解决两个问题。第一、日志通常是非结构化的，
我们需要从中提取出和任务相关的信息。第二、推断任务之间的层次关系，构建
层次结构的任务模型。我们的解决方法是，首先，提取出任务的名称与ID，接着，
通过推断任务ID的变化，来确定任务的边界，并推断任务的层次关系。例如，我
们可以在日志中发现这样的模式“request=R1, operation=op1○1 ……
request=R1, operation=op2○2 …… request=R2, operation=op3○
3”。request、operation是任务的名称，它们的值表示相应任务ID。通过观察
request任务ID的变化，我们可以推断R1任务的边界在○1处开始，在○3之前结
束，之间的日志条目都属于任务R1，描述它的执行过程。进一步，同一个日志条
目，可能属于多个任务，通过观察多个任务ID的变化关系，我们可以推断不同任
务之间的层次关系。例如，同时考虑任务request和 operation，我们发现，○1
○3之间的任务，同属于一个request任务R1，但是分属于不同的operation任务，
从而我们推断，request和operation任务之间，有层次嵌套关系。通过对日志中
所有的任务标识进行提取和推断，我们可以有效的构造出分层任务模型来。

我们实现了基于日志的任务模型推断工具，并使用它分析一个分布式存储系统
ChunkFS。ChunkFS是一个类似GFS[1]的分布式文件系统。我们的工具能够推断出
合乎逻辑的任务模型。应用推断的模型，帮助我们理解 ChunkFS的实际运行过程，
并解决了ChunkFS中的一个性能问题。经验表明，系统日志能够很好的反映出上
层语意，我们的工具可以有效的推断系统任务模型，帮助理解系统设计和运行时
行为。本文组织如下：第2节介绍了本文背景与相关工作，第3节详细描述了基于
日志的任务模型推断工具设计，第4节描述了我们使用基于日志的任务模型推断
工具，分析理解ChunkFS运行时行为、解决ChunkFS的一个性能问题的具体过程，
第5节是全文总结与进一步工作描述。

\section{设计}

图表 1是推断工具设计概要。我们首先从无结构的系统日志文本中提取出任务信
息，并用（key, value）形式表示。key是任务名称，value是任务ID。之后，我
们推断key也就是任务之间的层次关系。我们将层次关系转换为任务模型，并利
用任务模型分析系统动态行为。

\subsection{提取任务信息}

日志包含了大量系统活动信息。我们需要从无结构日志文本中提取描述任务行为
与状态的信息。日志中包含的信息通常可以表达成为（key，value）对的形式。
我们首先提取出所有的（key，value）对，并从中筛选出key是任务名称的（key，
value）对。我们使用的方法适用于ChunkFS的日志，其原理可以推广应用至其它
类型的日志。

图表 1顶部是一个ChunkFS日志的例子。不同系统的日志格式也不
相同，我们的日志格式是一个典型代表。日志头的部分记录了日志的级别、时间
、类别，紧接着是所在文件、函数和行号，最后是进程号、线程号。日志头是固
定格式的。日志的后半部分，包含在Notes域里。它是程序员记录的系统状态，
包含了文字描述与数值表达的系统状态参数。任务信息通常都记录在这里。

由于
Notes中的内容是无结构的，因此从中提取出（key，value）信息并不容易。我
们观察到，（key，value）在日志中通常被写成key SEP1 value SEP2的形式。
其中，SEP1是key和value的分隔符，SEP2是两个（key，value）之间的分隔符。
SEP1和SEP2的选择很多，可能是空格、逗号，分号等多种形式。从日志中，并不
容易确定哪个单词是key，因为key和文字描述中的单词可能是相同的形式，例如
POSTED: 和opId:。

我们使用了一种新颖的办法提取（key，value）信息。基于
对日志的观察，我们发现，value部分的格式是有限的，通常包括整数、十六进
制数和GUID，很容易使用正则表达式来匹配。一旦找到value部分，我们可以在
文字中向前跳过分隔符SEP1，遇到的第一个单词就是对应的key。

在少数情况下，
value也可能是一个单词。但是目前我们只提取value为数值格式的（key，value）
对。这是因为，1）文字形式的value只是对某个状态的简单描述，对于推断任务
层次关系用处不大，2）由于SEP1和SEP2可能是空格，在这种情况下，文字形式
的value，会和key、其它文字混淆，无法区分。

对提取出的（key，value）检查
时，我们发现，由于程序员创建日志时未对key的命名作严格约定，会产生下面
问题：1）同一个key会有多个别名，2）不同的key可能使用相同的名字（key冲
突）。我们使用命名映射同时解决了这两个问题。在解析完一个日志条目后，会
依据映射规则，把某些key转换为新名字。

映射规则的形式如（FileX, FuncY,
key）（newkey），表示如果一个日志条目的所属文件、函数是FileX、FuncY，
那么将这个条目中的key转换为新的名字newkey。FileX, FuncY可以使用正规表
达式。这样，key别名可以用（*, *, alias）（key）映射规则解决，而key冲
突问题可以用（FileX, FuncY, conflict key）（newkey）映射规则解决，从
实际经验看，通常只需要指明FuncY就可以解决冲突。

通常来说，并不是每个提取出的（key，value）对都描述任务信息，例如key是
error时，它描述的是某个任务执行的错误码。我们需要筛选出key表述任务名称
的（key，value）对来，这有两种情况。第一，key直接就是任务的名称，例如
Session。第二，key是与任务一一对应的请求或数据。例如key是requestID或
eventID，表示目前正在处理的请求/事件是requestID，requestID与任务有一一
对应关系，因此可以用 requestID代表正在处理它的任务。正确的判别key是否
描述任务信息，需要理解 key的语意。我们采用了半自动的方法来解决这一问题，
首先，使用正则表达式，筛选掉肯定不表达任务信息的key，例如*size*,
*err*, *offset*，接下来，请系统开发人员选出正确的key集合。采用这种方法，
我们能够筛选掉大部分的不表达任务信息的key，从而降低了开发人员的工作。

\subsection{推断任务层次关系}

实际系统中的任务是有层次关系的，表现为不同的任务之间嵌套关系。一个高层任务的执行，会被分解成为若干个底层任务。我们将任务之间的这种层次关系用＞表示，例如keyS＞keyP。keyS、keyP是任务名称。经过提取任务信息步骤，我们得到顺序的（key，value）任务信息序列，接下来，我们推断这个序列中key之间的关系，并输出一组（keyS，keyP，R）三元组，表示keyS＞keyP，且分数是R。

我们首先给出一个（key，value）序列的例子，如图表 2，以利于读者理解推断算法。图表 2中，摘取了从ChunkFS客户端日志中提取的任务序列片段，它的意义是：在任务Session s1中，处理了某个客户端命令，对stream x1进行操作，这些操作分成若干opId子任务执行，在opId 1中，首先进行了stream层次的操作，例如打开、创建一个stream，之后，opId 2/3对stream的不同chunk进行操作。
 
图表 2 任务信息(key, value)序列示例

我们使用如下两条规则从(key, value)序列中推断任务之间的层次关系，它们是两个任务有＞关系的充要条件。

	规则一：如果keyS＞keyP，那么在(key, value)序列中，keyS的第一次出现早于keyP的第一次出现。
	规则二：如果keyS＞keyP，那么keyS的值域与keyP的值域，有严格的一对多关系，也就是一个子任务，只能属于一个父任务。

通过规则一，我们可以得到所有任务之间可能的层次关系，通过规则二，我们将规则一得到的错误结果筛去。

推断算法详细描述如下。算法扫描（key，value）序列，并顺序更新三个数据结构。第一，每个key最新的value。第二，一个key数组，维护key之间的偏序关系，与规则一对应。数组中任何一个key，都是它后面key的潜在父任务。算法若遇到（key，value）对，其key不在key数组中，则将它加入数组。第三，任意两个key它们值域（value）的对应关系，与规则二对应。对每个扫描到的（keyP，valueP），将（valueS，valueP）加入（keyS，keyP）的值域对应关系（用一个数组维护），keyS是key数组中所有keyP前面的任务（即keyP的潜在父任务），valueS、valueP是keyS、keyP的当前值。

这样，当扫描完（key，value）序列所有数据后，我们得到每一对（keyS，keyP）的值域对应关系数组。应用规则二，判断是否keyS和keyP的值域有严格的一对多关系，如果满足条件，那么使用（valueS，valueP）数组的长度，作为（keyS，keyP）的分数R。

对图表 2中的例子，应用上面描述的算法，可以得出，StreamID＞ChunkID，分数为4，Session＞opId，分数为6。Session和StreamID之间没有层次关系，因为多个Session可能对应相同的StreamID。类似的（Session，ChunkID），（opId，StreamID）和（opId, ChunkID）也没有层次关系。

我们认识到，正确判断两个key是否有层次关系依赖于是否有足够多的数据，使得不存在层次关系的key使用规则二被筛选掉。通常情况下，系统日志都足够大，包含充分的数据，能够正确判断key的层次关系。

\subsection{构建分层任务模型}

经过上一步，我们得到了任务两两之间层次关系。将所有这些关系联系起来，得
到了所有任务之间的偏序关系，可以用一颗或多颗树来表达得到的偏序关系。每
一颗树都是一个层次结构的任务模型。在树中，每个节点都是一个任务，在实际
执行过程中，这个任务的执行过程包含若干它的子任务。程序员可以选择任意一
个任务模型对系统进行分析。为表示清晰起见，若原有任务模型的树根是
RootTask，我们增加一个新的节点Runtime，令它为RootTask的父节点，表示系
统运行时行为，由若干RootTask构成。

例如，对图表 2，可以得到两个任务模型，RuntimeSession, SessionopId
和RuntimeStreamID, StreamIDChunkID。

我们将任务模型应用在系统日志上，将系统运行时行为分为有层次的任务实例，
每个实例都由一组系统日志构成，描述一段时间内的系统活动。系统行为首先从
任务模型的树根开始，分为高层任务实例。每个任务实例开始于任务ID被赋予一
个新的值，结束于任务ID被赋予另外一个值之前。在每个任务实例内部，被递归
的分为更低层的任务实例。

对于图表 2中的例子，我们应用RuntimeSession, SessionopId任务模型，
得到图表 3中的有层次的任务实例。

我们认识到，系统运行时包含若干线程，因此“推断任务层次关系”与“构建分
层任务模型”两个步骤都是对每个线程分别操作，并使用基于数值的join操作
[7]将不同线程的任务联系在一起。

