% vim:textwidth=70
\chapter{基于日志的系统任务模型推断方法}
\label{chap:logmining}

\section{本章引言}

随着云计算逐渐影响人们的生活，分布式系统变的越来越重要，成了Internet应
用的关键组成部分~\cite{gfs, mapreduce, bigtable, dynamo}。分布式系统运
行在多台机器上，充分发掘并调度机器资源，以提供高吞吐率、低延迟的服务，
同时，还要处理各种不同类型的系统失败事件（failure）。由于系统规模庞大，
并且有严格的服务质量要求，设计与实现这类分布式系统不可避免的会产生错误
（bug），从而使系统表现出未预期的行为。系统错误的根本原因通常隐含在复
杂的应用逻辑之下，找到这些错误通常会花费很长时间。

理解分布式系统的运行时行为是验证系统设计、发现系统逻辑与性能问题、解决
系统实现错误的关键。然而，即使对系统的实现者来说，充分理解系统逻辑也不
是一件轻而易举的事情。这是因为，系统设计非常复杂，它的运行时行为多种多
样。再者，系统通常由一组程序员共同开发，并且在不停的演变至新的版本。进
一步说，分布式系统通常会使用分层的设计模式，用户请求由不同层次的模块处
理。上层模块中的某个函数，会由下层模块的多个函数一起完成，其完成方式，
可能是顺序的，也可能是并行的，跨越多个机器、进程与线程。以上这些状况，
都增加了理解系统运行时行为的困难。

已有的方法表明，用分层的任务模型去表达系统行为，可以很好的帮助程序员理
解与验证系统。例如，Pip~\cite{pip}允许程序员定义可嵌套的任务流，并定义
“期望”，来发现异常。用这个方法，程序员能够定义并验证系统特定层次的特
性。这种方法被证明能够很有效的发现系统错误与性能问题。我们之前的工作
Scalpel~\cite{scalpel}进一步发展了一种方法，能够从底层系统调用trace中，
自动推断任务模型，从而避免了手动定义任务结构的工作。初步的结果表明，从
操作系统级别的同步操作，我们能够推断出合理的表达上层语意的层次化任务模
型。利用得到的模型，我们能够帮助程序员快速的发现并解决系统性能问题。

我们最终的目标是设计一个完全不需要或尽可能少需要人工标注的工具，来自动
提取系统的分层任务模型，帮助程序员、测试人员和系统管理员理解系统运行时
行为。基于之前的工作，在本文中，我们重点研究了如何利用应用日志（log）
来推断任务模型。其基本原理是，相比底层 trace，应用日志包含了更多的应用
层任务流的语意。日志是由系统开发人员创建的，因此它们包含了关键的系统状
态和事件信息，例如，用户层任务的开始和结束，处理用户请求的关键步骤等等。
利用这些信息，可以帮助我们推断用户层语意，而这些很难从系统调用trace中
得到。

使用日志推断分层任务模型需要解决两个问题。第一、日志通常是非结构化的，
我们需要从中提取出和任务相关的信息。第二、推断任务之间的层次关系，构建
层次结构的任务模型。我们的解决方法是，首先，提取出任务的名称与ID，接着，
通过推断任务ID的变化，来确定任务的边界，并推断任务的层次关系。例如，我
们可以在日志中发现这样的模式“request=R1, operation=op1\textcircled{1}
……request=R1, operation=op2\textcircled{2} …… request=R2,
operation=op3\textcircled{3}”。request、operation是任务的名称，它们的
值表示相应任务ID。通过观察request任务ID的变化，我们可以推断R1任务的边
界在\textcircled{1}处开始，在\textcircled{3}之前结束，之间的日志条目都
属于任务R1，描述它的执行过程。进一步，同一个日志条目，可能属于多个任务，
通过观察多个任务ID的变化关系，我们可以推断不同任务之间的层次关系。例如，
同时考虑任务request和 operation，我们发现，\textcircled{1}
\textcircled{3}之间的任务，同属于一个request任务R1，但是分属于不同的
operation任务，从而我们推断，request和operation任务之间，有层次嵌套关
系。通过对日志中所有的任务标识进行提取和推断，我们可以有效的构造出分层
任务模型来。

我们实现了基于日志的任务模型推断工具，并使用它分析一个分布式存储系统
ChunkFS。ChunkFS是一个类似GFS~\cite{gfs}的分布式文件系统。我们的工具能
够推断出合乎逻辑的任务模型。应用推断的模型，帮助我们理解 ChunkFS的实际
运行过程，并解决了ChunkFS中的一个性能问题。经验表明，系统日志能够很好
的反映出上层语意，我们的工具可以有效的推断系统任务模型，帮助理解系统设
计和运行时行为。

本文组织如下：第2节介绍了本文背景与相关工作，第3节详细
描述了基于日志的任务模型推断工具设计，第4节描述了我们使用基于日志的任
务模型推断工具，分析理解ChunkFS运行时行为、解决ChunkFS的一个性能问题的
具体过程，第5节是全文总结与进一步工作描述。

\section{推断方法设计}

图表 1是推断工具设计概要。我们首先从无结构的系统日志文本中提取出任务信
息，并用（key, value）形式表示。key是任务名称，value是任务ID。之后，我
们推断key也就是任务之间的层次关系。我们将层次关系转换为任务模型，并利
用任务模型分析系统动态行为。

\subsection{提取任务信息}

日志包含了大量系统活动信息。我们需要从无结构日志文本中提取描述任务行为
与状态的信息。日志中包含的信息通常可以表达成为（key，value）对的形式。
我们首先提取出所有的（key，value）对，并从中筛选出key是任务名称的（key，
value）对。我们使用的方法适用于ChunkFS的日志，其原理可以推广应用至其它
类型的日志。

图表 1顶部是一个ChunkFS日志的例子。不同系统的日志格式也不
相同，我们的日志格式是一个典型代表。日志头的部分记录了日志的级别、时间
、类别，紧接着是所在文件、函数和行号，最后是进程号、线程号。日志头是固
定格式的。日志的后半部分，包含在Notes域里。它是程序员记录的系统状态，
包含了文字描述与数值表达的系统状态参数。任务信息通常都记录在这里。

由于
Notes中的内容是无结构的，因此从中提取出（key，value）信息并不容易。我
们观察到，（key，value）在日志中通常被写成key SEP1 value SEP2的形式。
其中，SEP1是key和value的分隔符，SEP2是两个（key，value）之间的分隔符。
SEP1和SEP2的选择很多，可能是空格、逗号，分号等多种形式。从日志中，并不
容易确定哪个单词是key，因为key和文字描述中的单词可能是相同的形式，例如
POSTED: 和opId:。

我们使用了一种新颖的办法提取（key，value）信息。基于
对日志的观察，我们发现，value部分的格式是有限的，通常包括整数、十六进
制数和GUID，很容易使用正则表达式来匹配。一旦找到value部分，我们可以在
文字中向前跳过分隔符SEP1，遇到的第一个单词就是对应的key。

在少数情况下，
value也可能是一个单词。但是目前我们只提取value为数值格式的（key，value）
对。这是因为，1）文字形式的value只是对某个状态的简单描述，对于推断任务
层次关系用处不大，2）由于SEP1和SEP2可能是空格，在这种情况下，文字形式
的value，会和key、其它文字混淆，无法区分。

对提取出的（key，value）检查
时，我们发现，由于程序员创建日志时未对key的命名作严格约定，会产生下面
问题：1）同一个key会有多个别名，2）不同的key可能使用相同的名字（key冲
突）。我们使用命名映射同时解决了这两个问题。在解析完一个日志条目后，会
依据映射规则，把某些key转换为新名字。

映射规则的形式如（FileX, FuncY,
key）（newkey），表示如果一个日志条目的所属文件、函数是FileX、FuncY，
那么将这个条目中的key转换为新的名字newkey。FileX, FuncY可以使用正规表
达式。这样，key别名可以用（*, *, alias）（key）映射规则解决，而key冲
突问题可以用（FileX, FuncY, conflict key）（newkey）映射规则解决，从
实际经验看，通常只需要指明FuncY就可以解决冲突。

通常来说，并不是每个提取出的（key，value）对都描述任务信息，例如key是
error时，它描述的是某个任务执行的错误码。我们需要筛选出key表述任务名称
的（key，value）对来，这有两种情况。第一，key直接就是任务的名称，例如
Session。第二，key是与任务一一对应的请求或数据。例如key是requestID或
eventID，表示目前正在处理的请求/事件是requestID，requestID与任务有一一
对应关系，因此可以用 requestID代表正在处理它的任务。正确的判别key是否
描述任务信息，需要理解 key的语意。我们采用了半自动的方法来解决这一问题，
首先，使用正则表达式，筛选掉肯定不表达任务信息的key，例如*size*,
*err*, *offset*，接下来，请系统开发人员选出正确的key集合。采用这种方法，
我们能够筛选掉大部分的不表达任务信息的key，从而降低了开发人员的工作。

\subsection{推断任务层次关系}

实际系统中的任务是有层次关系的，表现为不同的任务之间嵌套关系。一个高层
任务的执行，会被分解成为若干个底层任务。我们将任务之间的这种层次关系用
＞表示，例如keyS＞keyP。keyS、keyP是任务名称。经过提取任务信息步骤，我
们得到顺序的（key，value）任务信息序列，接下来，我们推断这个序列中key
之间的关系，并输出一组（keyS，keyP，R）三元组，表示keyS＞keyP，且分数
是R。

我们首先给出一个（key，value）序列的例子，如图表 2，以利于读者理解推断
算法。图表 2中，摘取了从ChunkFS客户端日志中提取的任务序列片段，它的意
义是：在任务Session s1中，处理了某个客户端命令，对stream x1进行操作，
这些操作分成若干opId子任务执行，在opId 1中，首先进行了stream层次的操作，
例如打开、创建一个stream，之后，opId 2/3对stream的不同chunk进行操作。
 
图表 2 任务信息(key, value)序列示例

我们使用如下两条规则从(key, value)序列中推断任务之间的层次关系，它们是
两个任务有＞关系的充要条件。

规则一：如果keyS$>$keyP，那么在(key, value)序列中，keyS的第一次
出现早于keyP的第一次出现。

规则二：如果keyS$>$keyP，那么keyS的值域与keyP的值域，有严格的一对多关系，
也就是一个子任务，只能属于一个父任务。

通过规则一，我们可以得到所有任务之间可能的层次关系，通过规则二，我们将
规则一得到的错误结果筛去。

推断算法详细描述如下。算法扫描（key，value）序列，并顺序更新三个数据结
构。第一，每个key最新的value。第二，一个key数组，维护key之间的偏序关系，
与规则一对应。数组中任何一个key，都是它后面key的潜在父任务。算法若遇到
（key，value）对，其key不在key数组中，则将它加入数组。第三，任意两个
key它们值域（value）的对应关系，与规则二对应。对每个扫描到的
（keyP，valueP），将（valueS，valueP）加入（keyS，keyP）的值域对应关系
（用一个数组维护），keyS是key数组中所有keyP前面的任务（即keyP的潜在父
任务），valueS、valueP是keyS、keyP的当前值。

这样，当扫描完（key，value）序列所有数据后，我们得到每一对（keyS，keyP）
的值域对应关系数组。应用规则二，判断是否keyS和keyP的值域有严格的一对多
关系，如果满足条件，那么使用（valueS，valueP）数组的长度，作为（keyS，
keyP）的分数R。

对图表 2中的例子，应用上面描述的算法，可以得出，StreamID＞ChunkID，分
数为4，Session＞opId，分数为6。Session和StreamID之间没有层次关系，因为
多个Session可能对应相同的StreamID。类似的（Session，ChunkID），（opId，
StreamID）和（opId, ChunkID）也没有层次关系。

我们认识到，正确判断两个key是否有层次关系依赖于是否有足够多的数据，使
得不存在层次关系的key使用规则二被筛选掉。通常情况下，系统日志都足够大，
包含充分的数据，能够正确判断key的层次关系。

\subsection{构建分层任务模型}

经过上一步，我们得到了任务两两之间层次关系。将所有这些关系联系起来，得
到了所有任务之间的偏序关系，可以用一颗或多颗树来表达得到的偏序关系。每
一颗树都是一个层次结构的任务模型。在树中，每个节点都是一个任务，在实际
执行过程中，这个任务的执行过程包含若干它的子任务。程序员可以选择任意一
个任务模型对系统进行分析。为表示清晰起见，若原有任务模型的树根是
RootTask，我们增加一个新的节点Runtime，令它为RootTask的父节点，表示系
统运行时行为，由若干RootTask构成。

例如，对图表 2，可以得到两个任务模型，RuntimeSession, SessionopId
和RuntimeStreamID, StreamIDChunkID。

我们将任务模型应用在系统日志上，将系统运行时行为分为有层次的任务实例，
每个实例都由一组系统日志构成，描述一段时间内的系统活动。系统行为首先从
任务模型的树根开始，分为高层任务实例。每个任务实例开始于任务ID被赋予一
个新的值，结束于任务ID被赋予另外一个值之前。在每个任务实例内部，被递归
的分为更低层的任务实例。

对于图表 2中的例子，我们应用RuntimeSession, SessionopId任务模型，
得到图表 3中的有层次的任务实例。

我们认识到，系统运行时包含若干线程，因此“推断任务层次关系”与“构建分
层任务模型”两个步骤都是对每个线程分别操作，并使用基于数值的join操作
[7]将不同线程的任务联系在一起。

\section{应用}

在这一节，我们报告使用第3节中的推断工具，从ChunkFS日志中提取任务模型，
并应用模型理解ChunkFS动态行为。同时，我们也描述了，如何利用任务模型，
解决系统的性能问题。

\subsection{理解系统运行时行为}

ChunkFS是一个分布式存储系统，它类似于GFS。ChunkFS由一个master和若干个
chunkserver构成。在ChunkFS中，数据被组织成一个个stream，对应GFS中的文
件概念。每个stream，由若干chunk构成。每个stream和chunk都有唯一的GUID标
识。我们在集群环境下部署一个ChunkFS实例，包含一个master，若干个
chunkserver。接下来，向ChunkFS中随机的上传了若干文件，在上传命令之间，
还随机插入了若干查询命令，获取已上传文件的属性。

首先分析ChunkFS客户端行为。我们发现ChunkFS客户端运行时有两类线程：一个
client线程和若干个worker线程。Client线程的任务模型是RuntimeSession,
SessionopId，worker线程的任务模型是Runtime opId。

Client线程接收用户命令，每个用户命令，由一个新的session任务执行，
session任务被分为若干步骤，每一步是一个opId任务。在一个opId中，会发起
一到多个RPC调用，client线程并不直接调用RPC命令，而是将这个调用放入一个
RPC队列。Worker线程从RPC队列中取出RPC命令，并调用它们。当RPC命令返回时，
worker线程向client线程报告RPC调用的结果。对worker线程来说，它们的行为
被分为若干opId任务。Client线程和worker线程通过相同的opId联系到一起。

我们详细的观察了上传文件至ChunkFS的过程，如图表 4所示。在客户端，创建
新stream命令涉及一个session和4个opId，有6个RPC调用，具体过程是（create
stream），（append stream，append chunk），（append chunk），（append
chunk，seal the chunk）。每个括号代表一个opId任务，括号内是RPC调用。由
于文件小于chunk大小的最大值，创建的stream只有一个chunk，其内容由3次
append chunk RPC调用写入。在最后一次append chunk RPC调用之后，chunk被
封装，即seal chunk RPC调用，之后，chunk不能再被写入或追加（append）。

 
图表 4 创建一个Stream操作，ChunkFS客户端运行时行为。每个圆圈代表一个
opId任务，整个四个圆圈代表一个Session任务


我们同时观察在primary chunkserver端的运行时行为。Chunkserver端运行时包
括若干线程，其任务模型是RuntimeChunkID。具体的，创建一个
stream，Chunksever会接到5个RPC调用，如图表 5所示，分别是create chunk,
3个append chunk和seal chunk。可观察到的chunkserver行为的粒度被限制在对
chunk操作的级别（ChunkID任务），因此5个RPC处理被认为是同一个任务实例。

 
图表 5创建一个Stream操作，ChunkFS Chunkserver运行时行为。5个RPC被当作
一个ChunkID任务，因为它们都对同一个Chuck进行操作。


经验：使用任务模型，我们可以有效的把系统运行时活动分为不同层次的任务实
例，有效的理解系统行为。任务模型实际上是隐含在系统设计中的，利用任务模
型从上至下的分解系统活动是有效的。

我们注意到，使用任务模型，也会产生一些不精确的地方。第一、任务边界可能
会有位移。通常任务都有一个初始化步骤，在这期间，任务标识可能还没有产生，
因此使用任务标识的变化来确定任务边界，会把初始化部分划分到上一个任务的
尾部。考虑到初始化部分通常是比较固定的若干步骤，可以对任务边界增加一个
修正量，解决这一问题。第二、任务的粒度依赖与任务模型的精确程度。例如在
先前的chunkserver例子中，5个RPC是五个不同的任务，但是由于使用Runtime
ChunkID模型，且这5个RPC处理是连续的，所以会被认为是同一个任务。


\subsection{解决系统性能问题}

使用任务模型可以帮助解决系统的性能问题。通过对ChunkServer测试，我们发
现它的网络函数库的性能指标不能达到要求。在一项压力测试中，我们使用若干
并行线程，不断发起负载大小固定的RPC调用。我们发现，无论如何改变测试参
数（并行线程数、RPC负载大小），也不能够完全占用网络带宽，同时CPU使用率
也不到100\%，而相同的参数，在使用其它网络函数库时，是可以完全占用网络
带宽的。

根据我们先前的经验，系统性能问题，通常由于复杂的应用逻辑所引起，其根源
隐藏在庞大的代码库中。我们使用任务模型寻找产生性能问题的原因，并帮助定
位产生问题的代码。

我们重复了之前的压力测试，区分每一次RPC调用为不同的任务实例，并收集任
务相关的时间信息和资源使用情况。我们确认了网络带宽和CPU资源都远远不能
被充分利用，图表 6和图表 7显示了RPC调用被执行的情况。图表 6显示了
client线程运行情况。10个Client线程不断的创建RPC调用，并将它们放入一个
共享队列，若干worker线程从队列中取出RPC调用，并执行它们，图表 7显示了
worker线程执行RPC调用的过程。

 
图表 6 client线程任务运行情况

 
图表 7 worker线程任务运行情况

从图上立刻可以发现。Worker线程的执行过程呈现出被序列化的现象。虽然有4
个worker线程，但是他们调用RPC的任务的过程没有重叠，每一个时刻，只有一
个worker线程在工作。通过检查worker线程的工作模型，我们发现了问题的根源。
为了使系统具有可扩展性（extensibility），worker线程不直接调用RPC，而是
使用processor对象去处理RPC调用。Processor对象是在worker线程间共享的，
并且对每个TCP连接只创建一个processor对象。因此，processor对象成为了资
源瓶颈，由于它只有一个，导致了若干worker线程被迫以序列化的方式工作。

经验：任务模型在帮助推断、解释系统问题时非常有用。通过分析任务之间的依
赖关系，共享资源（包括CPU、I/O，共享数据、变量、锁等）的使用情况，可以
有效的推断由资源冲突引起的系统性能问题。



\section{相关工作}

\section{本章小结}
