\section{Analysis}
\label{sec:analysis}

We analyze performance of SMON in this section.

SMON uses epidemic algorithm to maintain itself. Peers will
initiate periodic communication to other random peers. We
will show that these maintenance tasks have good
performance and scalability. In the analysis, we assume that
SMON works in sychronized way, that is each peer performs
its maintenance tasks in synchronized rounds and the tasks
finish almost instantaneously. Although the real SMON system
works asynchronously, the analysis can still give insights
on performance of SMON design. We will also evaluate SMON in
real conditions (see section~\ref{sec:eval}) and validate
our analysis.

% performance and scalability

The epidemic algorithm has three variants, called push, pull
and push-pull, and they are used by different maintenance
tasks of SMON as summarized in table~\ref{tbl:tasks}.
Although they differ in details, the basic result of
epidemic theory shows that each one of the three methods can
eventually infect the entire population.  The studies also
show that starting from a single peer, this is achieved in
expected time (the rounds number) propotional to the log of
the population size ($\log N$).

\begin{table}
\centering
\begin{tabular}{|l|l|}

\hline
Self-deployment & push \\

\hline
Self-upgrade & push-pull \\

\hline
Self-recovery & push \\

\hline
Enable SMON & push \\

\hline
Disable SMON & pull \\

\hline
Application deployment & push-pull \\

\hline
\end{tabular}
\caption{Different variants of epidemic algorithm used by
maintenance task of SMON.}
\label{tbl:tasks}
\end{table}

Take self-deployment process as an example. Starting from a
single SMON peer, all the target machines will be deployed
with a SMON peer.  According to existing
studies~\cite{Eugster2004}, the self-deployment process can
be modeled as a branching process with population $n$. After
$r$ rounds, the expected fraction of deployed machines is:

\begin{equation*}
Y_r \approx \frac{1}{1+ne^{-r}} 
\end{equation*}

The relation of $Y_r$ and $r$ is demostrated in
figure~\ref{fig:yr}.

\begin{figure}
\centering
\includegraphics[scale=0.618]{Y_r}
\caption{Relation of expected infected population $Y_r$ with
round number $r$.}
\label{fig:yr}
\end{figure}


The ratio of deployed machines to undeployed ones increases
exponentially, on average, by a factor of $e$ in each round.
This indicates that the self-deployment has good
performance.

To deploy a fix fraction of machines, the expected round
number $r$ is:

\begin{equation*}
r \approx \ln(n) - \ln(\frac{1}{Y_r} - 1)
\end{equation*}

$r$ is in the logarithm of total population $n$, which
implies good scalability of self-deployment process.

% overhead number

Another performance metric in concern is the overhead in
the self-deployment process. Since we use epidemic
algorithm, there may be duplicated deployed SMON peers in a
machine. Although there will be only one instance running,
the duplicated deployment will waste network resource and
disk storage at some extent.

We next show that the overhead is small on average. Assuming
that there are totally $n$ machines to be deployed with SMON
peers, and $m$ machines have been deployed already. For any
one of $n-m$ un-deployed machines, it may be selected by $k,
(k <= m)$ peers as the deployment target in the next round.
The distribution of $k$ is can be expressed as binomial
distribition with parameter $(m, \frac{1}{n})$. We define
the simultaneous deployment number $k$ as the deployment
overhead. It can be seen that the expectation of $k$ is
$m/n$ and never be greater than 1. As more machines are
deployed with SMON peers, the expectation of $k$ will
approaching 1 while $m$ approaching $n$. Thus we prove that
the overhead small on average.

% ping overhead

% At last, we show that the communication cost caused by
% maintenance tasks is small. At each round, a SMON peer will
% selecte a random peer and send it two messages: a ping
% piggybacked with version number

% recover speed?


% vim:foldmethod=marker:textwidth=60
